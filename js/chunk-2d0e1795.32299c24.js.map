{"version":3,"sources":["webpack:///./src/views/base/2-fn/index.vue","webpack:///./src/views/base/2-fn/index.vue?be18"],"names":["handleBtn","alert","links","label","link","__exports__"],"mappings":"usDAwDA,MAAMA,EAAY,KAChBC,MAAM,cAGFC,EAAQ,CACZ,CACEC,MAAO,oCACPC,KAAM,0DAER,CACED,MAAO,4BACPC,KAAM,mE,mhBChEV,MAAMC,EAAc,EAEL","file":"js/chunk-2d0e1795.32299c24.js","sourcesContent":["<template>\r\n  <!-- 2-创建方法 -->\r\n  <div class=\"flex justify-between\">\r\n    <el-button type=\"primary\" @click=\"handleBtn\">点我试试</el-button>\r\n\r\n    <div class=\"italic text-sm font-semibold leading-6 mr-8\" style=\"width: 500px\">\r\n      <p>\r\n        <span class=\"text-xl\">注：</span>\r\n        当使用 &lt;script setup&gt; 的时候，任何在 &lt;script setup&gt; 声明的顶层的绑定 (包括变量，函数声明，以及\r\n        <span class=\"underline\">import 引入的内容</span>\r\n        ) 都能在模板中直接使用。\r\n      </p>\r\n    </div>\r\n  </div>\r\n\r\n  <div v-highlight class=\"mt-8\" style=\"width: 660px\">\r\n    <p class=\"font-bold\">组件代码：</p>\r\n    <pre>\r\n            <code>\r\n&lt;template&gt;\r\n  &lt;el-button type=\"primary\" @click=\"handleBtn\"&gt;点我试试&lt;el-button/&gt;\r\n&lt;/template&gt;\r\n\r\n&lt;script setup&gt;\r\n  import { ElMessageBox } from \"element-plus\";\r\n\r\n  const handleBtn = () => {\r\n    alert(\"你触发了点击事件！\");\r\n  };\r\n\r\n  // 这是一个async await使用示例\r\n  // 你可以把 ElMessageBox 替换成 axios 请求\r\n  const handleAsync = async () => {\r\n    let whichClose = true\r\n    await ElMessageBox.confirm(\"这是一个弹框\", \"提示\", {\r\n      confirmButtonText: \"确认\",\r\n      cancelButtonText: \"取消\",\r\n      type: \"success\",\r\n    })\r\n      .then(() => {\r\n        whichClose = true\r\n      })\r\n      .catch(() => {\r\n        whichClose = false\r\n      });\r\n    console.log(whichClose)\r\n  };\r\n&lt;/script&gt;\r\n            </code>\r\n        </pre>\r\n  </div>\r\n\r\n  <ReLink :links=\"links\" />\r\n</template>\r\n\r\n<script setup>\r\nconst handleBtn = () => {\r\n  alert(\"你触发了点击事件！\");\r\n};\r\n\r\nconst links = [\r\n  {\r\n    label: \"vue3 setup 模式中的方法不需要暴露给methods对象？\",\r\n    link: \"https://v3.cn.vuejs.org/api/sfc-spec.html#script-setup\",\r\n  },\r\n  {\r\n    label: \"vue3 setup 模式中的方法如何暴露给模板？\",\r\n    link: \"https://v3.cn.vuejs.org/api/sfc-script-setup.html#顶层的绑定会被暴露给模板\",\r\n  },\r\n];\r\n</script>\r\n","import script from \"./index.vue?vue&type=script&setup=true&lang=js\"\nexport * from \"./index.vue?vue&type=script&setup=true&lang=js\"\n\nconst __exports__ = script;\n\nexport default __exports__"],"sourceRoot":""}